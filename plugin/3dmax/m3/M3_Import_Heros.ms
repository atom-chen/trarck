/*
    ?015 Script by Taylor Mouse
	Starcraft II & Heroes of the Storm model import (.m3 & .m3a)
	Starcraft and Heroes of the Storm are reigistered trademarks of Blizzard Entertainment

*/
/*	Release notes

v2.1 Bug Fix, memory leak and material support for MAX 2012 and up

v2.0 Release to community
    v1.9 Support for latest release
    v1.8 Corrected Material setting for emissive and spcular multiplier
    v1.7 Extented Material Support
    v1.6 Added Camera import

v1.5 Release to Community
    v1.4 merged SC2 Art Tools stuff and No SC2 Art Stuff together
    v1.3 Fixed the weird animations
    v1.2 NO Art Tools required ( is a different script )
    v1.1 Bug Fixing added ReadBytes ( renamed it to ReadBytes_Helper)

v1.0 Released to Community
    v0.4 Added STC as animations
    v0.3 Corrected skinning
    v0.2 Making it usable and adding comments
    v0.1 Covering the basics

*/

/* GLOBALS */
GLOBAL ASSETS_FOLDER = @""

GLOBAL TAGS      = #()
GLOBAL SEQS_LIST = #()
GLOBAL STG_LIST  = #()
GLOBAL STS_LIST  = #()
GLOBAL STC_LIST  = #()
GLOBAL BONE_LIST = #()
GLOBAL IREF_LIST = #()
GLOBAL INDICES_LIST 	 = #()
GLOBAL VERTEX_LIST 		 = #()
GLOBAL NORMALS_LIST 	 = #()
GLOBAL UVW_LIST 		 = #()
GLOBAL UVW_LIST2 		 = #()
GLOBAL SUBMESH_LIST 	 = #()
GLOBAL MESHMAT_LIST 	 = #()
GLOBAL MATM_LIST		 = #()
GLOBAL ATVL_LIST		 = #()
GLOBAL ATT_LIST			 = #()
GLOBAL MAT_LIST          = #()
GLOBAL SSGS_LIST		 = #()
GLOBAL WEIGHTBONE_LIST   = #()
GLOBAL CAM_LIST  =#()
GLOBAL BONE_LOOKUP
GLOBAL gMODL
GLOBAL gFILETYPE
GLOBAL nbrValidSTCs = 0
GLOBAL nAnimationSeparate = 20
GLOBAL sCurrentFile = ""


GLOBAL bUseSC2ArtTools = true
GLOBAL bBuildBones = true
GLOBAL bBuildHitTest = true
GLOBAL bBuildAtt = true
GLOBAL bBuildAnim = true
GLOBAL bBuildMat = true
GLOBAL bBuildVolTarget = true
GLOBAL bBuildSkin = true
GLOBAL bSaveAnimationInfo = true

/* STRUCTS */
struct HEROES_TAG 		( Name, Offset, NbrItems, Flag, TagData ) /* 16 bytes */
struct HEROES_BoundBox 	( MinValue, MaxValue, Radius )
struct HEROES_LAYR   	( Id, TextureRefId )
struct HEROES_SEQS 		( Name, StartFrame, endFrame, MovementSpeed, Flags, NonLooping, Frequency, ReplayStart, ReplayEnd )
struct HEROES_STG		( Name, STC_ids )
struct HEROES_STS		( AnimationsIds )
struct HEROES_STC       ( Name, stsIndex, AnimationIds, AnimationRefs, runsConcurrent, priority, SDEV_data, SD2V_data, SD3V_data, SD4Q_data, SDCC_data, SDR3_data, SDS6_data, SDU6_data, SDU3_data, SDFG_data, SDMB_data, SEQ_refId, FirstFrame, LastFrame, NonLooping = false, Frequency = 100, MovementSpeed = 0 )
struct HEROES_AnimData  ( FrameList, Flags, EndFrame, Keys )
struct HEROES_AnimRef   ( sd, sdindx )
struct HEROES_BONE		( Id, Name, ParentBoneId, Position, Rotation, Scale,AnimRef,BillBoard1=false, billboard2=false, twoDProjection = false, InheritTranslation=false, InheritScale=false, InheritRotation=false, IsAnimated=false, InverseKinematics=false, Skinned=false, Real=false,  AnimRefPosition, AnimRefRotation, AnimRefScale, AnimRefAnim, TheBone )
struct HEROES_BoneAnimRef ( InterpolationType, animFlags, AnimId )
struct HEROES_IREF      ( Matrix )
struct HEROES_Submesh   ( Name, firstVertex, nVerts, firstIndex, nIndices, nBones,firstBoneLookup,nBoneLookup, nBoneWeightPairs, RootBoneId, TheMesh )
struct HEROES_MeshMat	( MeshId, MatId)
struct HEROES_MATM		( materialIndex, materialType )
struct HEROES_VOLTARGET ( type, size0, size1, size2,bone0, bone1,bone2, matrix )
struct HEROES_HITTEST   ( type, size0, size1, size2,boneId, matrix )
struct HEROES_ATT		( Name, ParentId )

struct HEROES_MODL	 	( Name, VerticesTAG, nSkinBones )
struct HEROES_WEIGHTBONE ( Weights, BoneIndexes )
struct HEROES_CAMERA    ( CamRef, BoneRefId )
struct MAX_ANIMATION ( FrameList, KeyList )

struct HEROES_NONSC2_MAT ( Name, Diff_Map, Norm_Map, Height_Map, Decal_Map, Spec_Map, Emis_Map, Emis2_Map, Env_Map, Envio_Map, Alpha_Map, Alpha2_Map, Light_Map, MaterialRef ) 


/*********************************************************************************************************************

	HELPER FUNCTIONS

*********************************************************************************************************************/
fn ResetGlobals=
(
	/* When reselectin a file, reset these so no data of previous files is retained */
    TAGS      = UNDEFINED
	TAGS      = #()
	SEQS_LIST = #()
	STG_LIST  = #()
	STS_LIST  = #()
	STC_LIST  = #()
	BONE_LIST = #()
	IREF_LIST = #()
	INDICES_LIST  	= #()
	VERTEX_LIST 	= #()
	NORMALS_LIST 	= #()
	UVW_LIST 		= #()
	UVW_LIST2 		= #()
	SUBMESH_LIST 	= #()
	MESHMAT_LIST 	= #()
	MATM_LIST		= #()
	ATVL_LIST		= #()
	ATT_LIST 		= #()
	MAT_LIST        = #()
	SSGS_LIST		= #()
	WEIGHTBONE_LIST   = #()
    CAM_LIST  =#()

	if( gFILETYPE ==".m3" ) then --> don't reset if this is a m3a (animation) file, it doesn't help :)
	(
		for m=1 to 24 do
		(
			meditMaterials[m] = Standardmaterial()
		)
	)
)


fn CreateAttachmentPt aName=
(
    theName = "SC2AttachPt001"

    ss = SplineShape pos:[0,0,0]
    ss.renderable = off
    ss.name = theName
    if( aName != undefined ) then ss.name = aName

    addNewSpline ss
    addKnot ss 1 #corner #curve [0,0,10]
    addKnot ss 1 #corner #curve [0,-4,0]
    close ss 1
    addNewSpline ss
    addKnot ss 2 #corner #curve [-4,0,0]
    addKnot ss 2 #corner #curve [4,0,0]
    addKnot ss 2 #corner #curve [0,0,10]
    close ss 2
    addNewSpline ss
    addKnot ss 3 #corner #curve [-4,0,0]
    addKnot ss 3 #corner #curve [0,-4,0]
    addKnot ss 3 #corner #curve [4,0,0]
    close ss 3
    ss.WireColor = yellow
    updateShape ss
    return ss
)

unRegisterRedrawViewsCallback ShowAttachmentPtLabels
fn ShowAttachmentPtLabels=
(
    gw.setTransform(Matrix3 1)
    for o in objects where not o.isHidden and (classof o == SplineShape )  do
    (
        gw.text o.pos ("N: " + o.name) color:yellow

    )
    gw.enlargeUpdateRect #whole
    gw.updateScreen()

)
registerRedrawViewsCallback ShowAttachmentPtLabels


fn ReadBytes_Helper stream val =
(
	for i=1 to val do ReadByte stream
)

fn ReadFourCC stream =
(
	/* Read 4 bytes (chars) backwards -> this is the way Blizzards stores their TAGS */
	ret = ""
	for i=1 to 4 do ret = (bit.IntAsChar(ReadByte stream)) + ret
	return ret
)

fn SkipBytes stream nBytesToSkip=
(
	/* Skip n-bytes without reading them into memory */
	fseek stream nBytesToSkip #seek_cur
)

fn ReadFixedString stream val =
(
	/* Read n-length string */
	local str = ""

	for i=1 to val do
	(
		s= bit.IntAsChar(ReadByte stream)

		if ( s !="\0") then str+=s
	)
	return str

)

fn CreateLayer layerName =
(
	/* Create layer in MAX, if it exists, just return a reference to that layer */

	layer = LayerManager.GetLayerFromName layerName
	if(layer == undefined) then
	(
		layer = LayerManager.NewLayerFromName layerName
	)
	return layer
)

fn ReplaceAll str source destination =
(
	/* Look for 'source' in as string and replace it, I use this to replace forward slashes with backslaches in a path */
	while ( findstring str source !=undefined ) do
	(
		local pos = findstring str source
		local len = source.count
		str = replace str pos len destination
	)
	return str
)

fn ValidateTexture texture=
(
	/*
		If a model comes from Blizzard, it stores a reletive path to the texture, so I need to add the folder,
		if it is an exported model from max, it has an explicit path, so not folder needs to be added
	*/

	if(texture == undefined ) then return undefined
	if(texture == "" ) then return undefined

	print ( replaceAll texture "/" "\\" )
	if(doesFileExist (ASSETS_FOLDER + texture) ) then return (ASSETS_FOLDER + texture)

	--print HEROES_ASSETS_FOLDER

	if(ASSETS_FOLDER == undefined) then ASSETS_FOLDER = ""

	local t = replaceAll (ASSETS_FOLDER + texture) "/" "\\"
	print ("[INFO] Looking for " + t )

	if(doesFileExist t) then return t

	t = replaceAll t "\\BAS_" "\\storm_"
	print t
	if(doesFileExist t) then return t

	print ("[WARNING] Texture was not found ! (" + t + ")")

	return undefined
)

fn Read4x4Matrix stream=
(
	/* Reads a 4x4 matrix, but Max only knows a 3x4 matrix, if it is called a matrix3, so skip the fourth float */

	-- reads 16 * 4 bytes = 64bytes
	row1 = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
	 ReadFloat stream
	row2 = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
	 ReadFloat stream
	row3 = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
	 ReadFloat stream
	row4 = [ReadFloat stream * 100, ReadFloat stream * 100, ReadFloat stream * 100] -- Position
	 ReadFloat stream
	return ( inverse ( matrix3 row1 row2 row3 row4 ) )
)

fn ReadReference stream=
(
	/* This allow for easy coding, instead of typing these 3 lines each time, moves the stream forward by 12 bytes */
	local entries = ReadLong stream
	local tagIdx  = Readlong stream + 1
	local flag    = ReadLong stream

	return tagIdx
)

fn ReadCharTag stream tag=
(
	/* A char tag contains a set of characters that form a name, like a bone name */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local theName = ReadFixedString stream tag.NbrItems

	fSeek stream streamPosition #seek_set

	--print theName

	return theName
)

fn ReadLAYRTag stream tag=
(
	/* Reads a Layer tag, layer tags contain a reference to a texture */
	/* 464 bytes */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local size = 464
	local layr = HEROES_Layr()

	layr.Id = readLong stream
	readLong stream
	layr.TextureRefId = readLong stream

	readLong stream


	fSeek stream streamPosition #seek_set
	return layr
)

fn ReadU16_Tag stream tag=
(
	/* Read a set of unsigned shorts of 2 bytes */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values (ReadShort stream #unsigned)

	)
	fSeek stream streamPosition #seek_set

	return values
)

fn ReadI16_Tag stream tag=
(
	/* Read a set of Signed shorts of 2 bytes */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values (ReadShort stream #signed)

	)
	fSeek stream streamPosition #seek_set

	return values
)

fn ReadU32_Tag stream tag=
(
	/* Reads a set of unsigned integers (or longs) of 4 bytes each*/
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values (ReadLong stream #unsigned)

	)
	fSeek stream streamPosition #seek_set

	return values
)

fn ReadI32_Tag stream tag=
(
	/* Reads a set of signed integers (or longs) of 4 bytes each */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values (ReadLong stream #signed)
	)

	fSeek stream streamPosition #seek_set

	return values

)

fn ReadVEC2_Tag stream tag=
(
	/* Reads a set of 2 floats, resulting in a Vector 2 -> 2 floats per vector */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values [ReadFloat stream, ReadFloat stream]
	)

	fSeek stream streamPosition #seek_set

	return values
)

fn ReadVEC3_Tag stream tag=
(
	/* Reads a set of 3 floats, resulting in a Vector 3 -> 3 floats per vector, like position, rotation,  etc */

	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values ([ReadFloat stream, ReadFloat stream, ReadFloat stream])
	)

	fSeek stream streamPosition #seek_set

	return values
)

fn ReadREAL_Tag stream tag=
(
	/* Reads a set of floats, 1 floats per read, scale, etc */

	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values (ReadFloat stream)
	)

	fSeek stream streamPosition #seek_set

	return values
)

fn ReadQUAT_Tag stream tag=
(
	/* Reads a set of 4 floats, resulting in a Quaternian -> 4 floats per Quaternian, like rotation */

	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(
		append values ( quat (ReadFloat stream) (ReadFloat stream) (ReadFloat stream) (ReadFloat stream) )
	)

	fSeek stream streamPosition #seek_set

	return values
)

fn ReadSD_Tag stream tag=
(
	/* Read Sequence Definitions */
	/* 32 bytes per sd3v */

	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()

	for i=1 to tag.nbrItems do
	(
		local sd = HEROES_AnimData()
		local entries  = ReadLong stream
		local indx     = Readlong stream + 1
		local flag     = ReadLong stream

		sd.FrameList = TAGS[indx]
		sd.Flags = ReadLong stream
		sd.EndFrame = ReadLong stream

		entries  = ReadLong stream
		indx     = Readlong stream + 1
		flag     = ReadLong stream

		sd.Keys = TAGS[indx] --> this is a vec3 so this is probably the animated keys for the position?

		append values sd
	)
	fSeek stream streamPosition #seek_set

	return values
)

fn ReadBNDS_Tag stream tag=
(
	/* Read bounding boxes */
	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()
	for i=1 to tag.nbrItems do
	(

		local bb = HEROES_BoundBox()

		bb.MinValue = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
		bb.MaxValue = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
		bb.Radius   = ReadFloat stream

		append values bb
	)

	fSeek stream streamPosition #seek_set

	return values
)

/* 	SEQS - Animation sequences */
fn Read_SEQS stream idx=
(
	if( idx==0) then
	(
		return undefined
	)

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set
	size = 0
	if(tag.Flag == 1) then size = 96
	if(tag.Flag == 2) then size = 92

	startFrame = 50

	for i=1 to tag.NbrItems do
	(

		local seqs = HEROES_SEQS()

		SkipBytes stream 8 --> FF FF FF FF  FF FF FF FF

		local tagIdx  = ReadReference stream
		seqs.Name = "Not Found " + i as string
		if(tagIdx <= TAGS.Count) then
		(
			if(TAGS[tagIdx].TagData != undefined) then seqs.Name = TAGS[tagIdx].TagData
		)
		seqs.StartFrame    = ReadLong stream --/ ( 1000.0 / framerate ) as integer
		seqs.endFrame 	   = ReadLong stream --/ ( 1000.0 / framerate ) as integer
		seqs.MovementSpeed = ReadLong stream
		seqs.Flags 		   = ReadLong stream
		seqs.NonLooping    = false

		if( (bit.and seqs.Flags 0x1) > 0 ) then seqs.NonLooping = True

		seqs.Frequency	   = ReadLong stream
		seqs.ReplayStart   = ReadLong stream
		seqs.ReplayEnd	   = ReadLong stream


		append SEQS_LIST seqs

		SkipBytes stream (size - 20 - 16 - 12 )
	)

	print SEQS_LIST
)

/* STG - Sequence transformation group */
fn Read_STG stream idx=
(
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	for i=1 to tag.NbrItems do
	(
		local stg = HEROES_STG()

		local tagIdx  = ReadReference stream
		stg.Name  = TAGS[tagIdx].TagData

		tagIdx  = ReadReference stream
		stg.STC_ids = TAGS[tagIdx].TagData --> zero based, so +1 is required!!

		append STG_LIST stg
	)

	print STG_LIST

)
/* Read STS */
fn Read_STS stream idx=
(
	if( idx==0) then
	(
		return undefined
	)

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	for i=1 to tag.NbrItems do
	(
		local sts = HEROES_STS()

		local tagIdx  = ReadReference stream
		sts.AnimationsIds = TAGS[tagIdx].TagData

		SkipBytes stream (28 - 12 )

		append STS_LIST sts
	)
	--print STS_LIST
)

/* Read animation reference for Sequence Definitions */
fn ReadAnimRef stream tag=
(

	local streamPosition = fTell stream
	fSeek stream tag.Offset #seek_set

	local values = #()

	for i=1 to tag.nbrItems do
	(
		local ref = HEROES_AnimRef()
		ref.sd  = ReadShort stream #unsigned  +1
		ref.sdindx = ReadShort stream #unsigned  +1

		append values ref
	)
	fSeek stream streamPosition #seek_set

	return values

)

/* READ STC */
fn Read_STC stream idx=
(
	if( idx==0) then
	(
		return undefined
	)

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set
	size = 0
	if(tag.Flag == 4 ) then size = 204

	for i=1 to tag.NbrItems do
	(
		local stc = HEROES_STC()

		local tagIdx  = ReadReference stream
		stc.Name = TAGS[tagIdx].TagData

		stc.runsConcurrent = ReadShort stream
		stc.priority = ReadShort stream
		stc.stsIndex = ReadShort stream
		stsIndex = ReadShort stream

		local tagIdx  = ReadReference stream
		stc.AnimationIds = TAGS[tagIdx].TagData

		local tagIdx  = ReadReference stream

		stc.AnimationRefs = ReadAnimRef stream TAGS[tagIdx]

		SkipBytes stream 4

		stc.SDEV_data = TAGS[(ReadReference stream)].TagData
		stc.SD2V_data = TAGS[(ReadReference stream)].TagData
		stc.SD3V_data = TAGS[(ReadReference stream)].TagData
		stc.SD4Q_data = TAGS[(ReadReference stream)].TagData
		stc.SDCC_data = TAGS[(ReadReference stream)].TagData
		stc.SDR3_data = TAGS[(ReadReference stream)].TagData
		SkipBytes stream 12
		stc.SDS6_data = TAGS[(ReadReference stream)].TagData
		stc.SDU6_data = TAGS[(ReadReference stream)].TagData
		SkipBytes stream 12
		stc.SDU3_data = TAGS[(ReadReference stream)].TagData
		stc.SDFG_data = TAGS[(ReadReference stream)].TagData
		stc.SDMB_data = TAGS[(ReadReference stream)].TagData


		append STC_LIST stc
	)
	--print STC_List
)

/* READ MODEL */
fn Read_MODL stream idx=
(
	/*
		I only use this to get the correct index to the Vertices tag, since some models seem to have multiple tags for this...
		And for getting the list of skinned bones in the correct sequence
	*/

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	local modl = HEROES_MODL()

	modl.Name 	 =  TAGS[ ReadReference stream].TagData --> MODL
	flags 		 = ReadLong stream
	sequences    = TAGS[ ReadReference stream] 	--> SEQS
	seqTransColl = TAGS[ ReadReference stream] 	--> STC
	seqTransGrp  = TAGS[ ReadReference stream] 	--> STG

	SkipBytes stream 16

	seqTransSt   = TAGS[ ReadReference stream] 	--> STS
	bonestag	 = TAGS[ ReadReference stream]
	modl.nSkinBones 	 = ReadLong stream
	vFlags 		 = ReadLong stream
	modl.VerticesTAG = TAGS[ ReadReference stream]
	--print modl.VerticesTAG
	divisions	 = TAGS[ ReadReference stream]

	tmp = TAGS[ ReadReference stream]
	--print tmp
	skinnedBonesZeroBased  = tmp.TagData

	local skinnedBones = #()
	try(


	if( skinnedBonesZeroBased != undefined ) then
	(
		for i=1 to skinnedBonesZeroBased.count do
		(
			local sb = skinnedBonesZeroBased[i] + 1
			append skinnedBones sb
		)

		BONE_LOOKUP = skinnedBones
	)
)catch()

	SkipBytes stream (16 * 4 +12)

	gMODL = modl

	--print skinnedBones

	--print BONE_LOOKUP

	--print TAGS[(ReadReference stream)].TagData
)

/* READ BONES */
fn Read_BONE stream idx=
(
	/*
		THis is probably the most importent set of data, except for the meshes
		This also contains the reference to the names of lights, vol_target, hit test, meshes etc..

	TODO:
		1. make use of all the properties of the bones
		2. figure out how the (sub)mesh links to the bone that holds the name of the mesh

	*/
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	nBones = tag.NbrItems
	size = 0
	if( tag.Flag == 1) then size = 160

	for i=1 to nBones do
	(
		local b = HEROES_BONE()

		SkipBytes stream 4
		b.Id = i
		b.Name=  TAGS[ ReadReference stream ].TagData

		/* Only using 2 properties, isAnimated & Skinned */
		local flags = ReadLong stream
		if( bit.and flags 0x1 > 0 ) 	then b.InheritTranslation = true
		if( bit.and flags 0x2 > 0 ) 	then b.InheritScale = true
		if( bit.and flags 0x4 > 0 ) 	then b.InheritRotation = true
		if( bit.and flags 0x10 > 0 ) 	then b.Billboard1 = true
		if( bit.and flags 0x40 > 0 ) 	then b.Billboard2 = true
		if( bit.and flags 0x100 > 0 ) 	then b.twoDProjection = true
		if( bit.and flags 0x200 > 0 ) 	then b.IsAnimated = true
		if( bit.and flags 0x400 > 0 ) 	then b.InverseKinematics = true
		if( bit.and flags 0x800 > 0 ) 	then b.Skinned = true
		if( bit.and flags 0x2000 > 0 ) 	then b.Real = true

		b.ParentBoneId = (ReadShort stream #signed) + 1

		SkipBytes stream 2

		local posAnimRef = HEROES_BoneAnimRef()
		posAnimRef.InterpolationType =  ReadShort stream #signed
		posAnimRef.animFlags =  ReadShort stream #signed
		posAnimRef.AnimId =  ReadLong stream #signed

		b.AnimRefPosition = posAnimRef

		b.Position 	= [(ReadFloat stream) * 100.0, (ReadFloat stream) * 100.0, (ReadFloat stream) * 100.0 ]
		nullPos 	= [(ReadFloat stream) * 100.0, (ReadFloat stream) * 100.0, (ReadFloat stream) * 100.0 ]

		ReadBytes_Helper stream 4

		local rotAnimRef = HEROES_BoneAnimRef()
		rotAnimRef.InterpolationType =  ReadShort stream #signed
		rotAnimRef.animFlags =  ReadShort stream #signed
		rotAnimRef.AnimId =  ReadLong stream #signed

		b.AnimRefRotation = rotAnimRef

		b.Rotation 		= quat (ReadFloat stream) (ReadFloat stream) (ReadFloat stream) (ReadFloat stream)
		nullRotation 	= quat (ReadFloat stream) (ReadFloat stream) (ReadFloat stream) (ReadFloat stream)

		ReadBytes_Helper stream 4

		local scaleAnimRef = HEROES_BoneAnimRef()
		scaleAnimRef.InterpolationType =  ReadShort stream #signed
		scaleAnimRef.animFlags =  ReadShort stream #signed
		scaleAnimRef.AnimId =  ReadLong stream #signed

		b.AnimRefScale = scaleAnimRef

		b.Scale 		= [(ReadFloat stream) , (ReadFloat stream) , (ReadFloat stream)]
		nullScale 	    = [(ReadFloat stream) , (ReadFloat stream) , (ReadFloat stream)]

		ReadBytes_Helper stream 4

		local animRef = HEROES_BoneAnimRef()
		animRef.InterpolationType =  ReadShort stream #signed
		animRef.animFlags =  ReadShort stream #signed
		animRef.AnimId =  ReadLong stream #signed

		b.AnimRefAnim = animRef

		b.AnimRef 	  = ReadLong stream #unsigned
		NullAnimRef   = ReadLong stream #unsigned

		ReadBytes_Helper stream 4


		append BONE_LIST b
	)
	--print BONE_LIST
)

/* READ IREF */
fn Read_IREF stream idx=
(
	/*
		This contains the binding position of the bones and the mesh, this can be differenct from the original bone pose,
		if this is the case, it is nearly impossible to skin the model, so we need this binding pose
	*/
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	for b=1 to tag.NbrItems do
	(
		local iref = HEROES_IREF()

		row1 = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
		SkipBytes stream 4

		row2 = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
		SkipBytes stream 4

		row3 = [ReadFloat stream, ReadFloat stream, ReadFloat stream]
		SkipBytes stream 4

		row4 = [ReadFloat stream * 100, ReadFloat stream * 100, ReadFloat stream * 100] -- Position
		SkipBytes stream 4

		iref.Matrix = inverse ( matrix3 row1 row2 row3 row4 )

		append IREF_LIST iref

	)
	--print IREF_LIST


)

/* Read Indices */
fn Read_DIV stream idx=
(
	/* List of triangle definitions */
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	if(tag.flag == 2) then size = 52

	for i=1 to tag.NbrItems do
	(
		local faces = TAGS[ ReadReference stream ].TagData
		if(faces == undefined) then return undefined
		for f=1 to faces.Count do
		(

			append INDICES_LIST ( faces[f] + 1 )

		)
		SkipBytes stream (size - 12)
	)
	--print INDICES_LIST
)

/* Read Vertices, weights, normals and uvs*/
fn Read_VERT stream idx=
(
	/*
		Noticed that some models where not unwrapped, which is wrong, they are just unwrapped in a different uv channel,
		some type of models use only the second uv set, these are marked with useUVSet2, but the list is far from correct
		if a model is ever not correctly unwrapped, this probably means that the flag needs to be added or changed to use the 2nd set of uv mapping
	*/
	if( idx==0) then ( return undefined	)

	local tag = gMODL.VerticesTAG
	--print tag
	fseek stream 128 #seek_set

	flag = 0
	chunkSize = 32
	flag = ReadLong stream #unsigned
	useUVSet2 = false


	if(flag == 25297021) then chunkSize = 32
	if(flag == 25297533) then chunkSize = 36
	if(flag == 25296993) then chunkSize = 32
	if(flag == 25559649) then
	(
		chunkSize = 40
		useUVSet2 = true
	)
	if(flag == 25297505) then
	(
		chunkSize = 36
		useUVSet2 = true
	)
	if(flag == 25559677) then chunkSize = 40
	if(flag == 25559137) then chunkSize = 36
	if(flag == 25559165) then chunkSize = 36
	if(flag == 26083937) then
	(
		chunkSize = 44
		useUVSet2 = true
	)
	if(flag == 26083453) then chunkSize = 40
	if(flag == 26083425) then chunkSize = 40
	if(flag == 27132001) then chunkSize = 44
	if(flag == 27132513) then
	(
		chunkSize = 48
		useUVSet2 = true
	)
	if(flag == 1099038817) then chunkSize = 36
	if(flag == 1099300961) then chunkSize = 40
	if(flag == 1099038845) then chunkSize = 36
	if(flag == 1099300989) then chunkSize = 40
	if(flag == 27132029) then chunkSize = 44


	print ("Vertex chunksize: " +  chunkSize as string + "(" + flag as string + ")")

	nVerts = tag.nbrItems / chunkSize

	print ("nVerts " + nVerts as string)

	fSeek stream tag.OffSet #seek_set


	for v=1 to nVerts do
	(
		-- Position 12b
		x1 = ReadFloat stream * 100
		y1 = ReadFloat stream * 100
		z1 = ReadFloat stream * 100

		append VERTEX_LIST [ x1, y1, z1 ]

		-- BoneWeights 4b
		tmpWeights  =  [Readbyte stream  #unsigned, Readbyte stream  #unsigned, Readbyte stream  #unsigned, Readbyte stream  #unsigned]
		tmpBoneIndexes =  [Readbyte stream  #unsigned, Readbyte stream  #unsigned, Readbyte stream  #unsigned, Readbyte stream  #unsigned]

		local wb = HEROES_WEIGHTBONE()
		wb.Weights = #()
		wb.BoneIndexes = #()

		for w=1 to 4 do
		(
			local lWeight = tmpWeights[w]
			local lBoneIndex = tmpBoneIndexes[w]

			if( lWeight > 0 ) then
			(
				local decompressedWeight = lWeight / 255.0
				local correctedBoneId = (lBoneIndex + 1) as integer

				append wb.Weights decompressedWeight
				append wb.BoneIndexes correctedBoneId
			)

		)
		append WEIGHTBONE_LIST wb

		-- Vertex Normals 3b
		x4 = (((ReadByte stream #unsigned ) /255.0) * 2 ) - 1
		y4 = (((ReadByte stream #unsigned ) /255.0) * 2 ) - 1
		z4 = (((ReadByte stream #unsigned ) /255.0) * 2 ) - 1

		append NORMALS_LIST [ x4, y4, z4]

		ReadByte stream #unsigned --1b

		-- UV map 2b
		uvCorrection = 2048.0
		u5 = (ReadShort stream #signed ) / uvCorrection
		v5 = 1.0 - ((ReadShort stream #signed ) / uvCorrection )
		w5 = 0.0
		append UVW_LIST [ u5,v5,w5]

		if( chunkSize >=36) then
		(
			u6 = (ReadShort stream #signed ) / uvCorrection
			v6 = 1.0 - ((ReadShort stream #signed ) / uvCorrection )
			w6 = 0.0
			append UVW_LIST2 [ u6,v6,w6]

			ReadBytes_Helper stream (chunkSize - 32)
		)
		else
		(
			ReadBytes_Helper stream (chunkSize - 28)
		)

	)

	--print WEIGHTBONE_LIST

	/* Apply correct bone weights */



	if(useUVSet2) then
	(
		UVW_LIST = UVW_LIST2
		print "[WARNING] Swapped to UV set 2!!"
	)
)

/* Read Submeshes*/
fn Read_REGN stream idx=
(
	/*
		Very weird that the new version has an addition 4 bytes to be skipped since they are not used :/
	*/

	if( idx==0) then ( return undefined	)

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set
	subMeshSize = 0

	nSubmeshes = tag.NbrItems

	if( tag.Flag == 3 ) then subMeshSize = 36
	if( tag.Flag == 4 ) then subMeshSize = 40
    if( tag.Flag == 5 ) then subMeshSize = 48 --> bugfix as of beta release 35360

	--print tag.Flag

	for s=1 to nSubmeshes do
	(
		local submesh = HEROES_SUBMESH()
		local skip = subMeshSize

		ReadBytes_Helper stream 4

		skip -=4

		if( TAGS[1].name == "MD34") then --> MD34
		(
			ReadBytes_Helper stream 4
			submesh.firstVertex = (ReadLong stream #unsigned) as integer
			submesh.nVerts = (ReadLong stream #unsigned) as integer
			skip -=12
		)
		else --> MD33
		(
			submesh.firstVertex = (ReadShort stream #unsigned) as integer
			submesh.nVerts = (ReadShort stream #unsigned) as integer
			skip -=8
		)

		submesh.firstIndex = (ReadLong stream #unsigned) as integer
		submesh.nIndices = (ReadLong stream #unsigned) as integer
		skip -=8
		subMesh.nBones = (ReadShort stream #unsigned) as integer
		skip -=2
		subMesh.firstBoneLookup =  ((ReadShort stream #unsigned) as integer )
		subMesh.nBoneLookup =  ((ReadShort stream #unsigned) as integer )
		skip -=4
		ReadShort stream
		skip -=2
		subMesh.nBoneWeightPairs = ReadByte stream #unsigned
		Readbyte stream
		subMesh.RootBoneId = ReadShort stream
		skip -=4

		SkipBytes stream skip

		submesh.Name = "Mesh " + (s as string)

		append SUBMESH_LIST submesh
	)
	--print SUBMESH_LIST
	--print BONE_LIST
)


/* Read mesh matching material */
fn Read_BAT stream idx=
(
	/*
		List of the meshes with the reference to their material
	*/
	if( idx==0) then ( return undefined	)

	local tag = TAGS[idx]

	fseek stream tag.Offset #seek_set

	for b=1 to tag.nbrItems do
	(
		local mshMat = HEROES_MESHMAT()
		SkipBytes stream 4
		mshMat.MeshId = ReadShort stream +1
		SkipBytes stream 4
		mshMat.MatId = ReadShort stream +1
		SkipBytes stream 2
		append MESHMAT_LIST mshMat
	)
	--print MESHMAT_LIST

)

/* READ Material */
fn Read_MATM stream idx=
(
	/*
		Simple list that tells us what type of material is used, currently I only support standard materials (SC2Standard)
	*/

	if( idx==0) then ( return undefined	)

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	/*
		1	standard
		2	displacement
		3	composite
		4	terrain
		5	volume
		6   NOT USED
		7	creep
		8	noise
		9	splat
	*/

	for i=1 to tag.NbrItems do
	(
		local matm = HEROES_MATM()
		matm.materialType = ReadLong stream
		matm.materialIndex = ReadLong stream +1

		append MATM_LIST matm

	)
	--print MATM_LIST
)


/* Read and build the lights */
fn Read_LITE stream idx=
(
	/*
		Wild guess on importing lights, this is done on the fly, why, because StarTools already has a light structure,
		no need to re-declare it, just use the SC2OmniLight struct or the SC2SpotLight struct
	*/
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set
	print tag
	lightLayer = CreateLayer "Lights"

	if( tag.flag == 7 ) then size = 224
	skip = 0
	try
	(
		for i=1 to tag.NbrItems do
		(
			local l = undefined
			local lightType = ReadShort stream
			if( lightType == 1 ) then l = SC2OmniLight()
			if( lightType == 2 ) then
			(
				l = SC2SpotLight()
				l.target = Targetobject transform:(matrix3 [1,0,0] [0,1,0] [0,0,1] [0,0,0])
			)

			local boneIndex = ReadShort stream + 1
			l.name = BONE_LIST[boneIndex].Name
			l.pos = BONE_LIST[boneIndex].Position
			--l.rotation = BONE_LIST[boneIndex].Rotation

			l.Parent = BONE_LIST[boneIndex].TheBone


			local flags = ReadLong stream

			if( bit.and flags 0x1 > 0) then l.shadowCast = on
			if( bit.and flags 0x2 > 0) then l.Specular = on
			if( bit.and flags 0x4 > 0) then l.affectedByAO = on
			if( bit.and flags 0x8 > 0) then l.lightOpaqueObjects = on

			SkipBytes stream 8
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			r = ReadFloat stream * 255
			g = ReadFloat stream * 255
			b = ReadFloat stream * 255
			l.diffuseColor = color r g b

			SkipBytes stream 16
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			l.intensity = ReadFloat stream --> multiplier
			SkipBytes stream 8
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			r = ReadFloat stream * 255
			g = ReadFloat stream * 255
			b = ReadFloat stream * 255
			l.specularcolor = color r g b

			SkipBytes stream 16
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			l.specularMultiplier = ReadFloat stream

			SkipBytes stream 8
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			l.decay = ReadFloat stream * 100 as integer

			SkipBytes stream 12
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			l.attenStart = ReadFloat stream * 100 as integer

			SkipBytes stream 8
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			if( lightType == 2 ) then l.hotspot = readfloat stream * 57.2958

			SkipBytes stream 8
			SkipBytes stream 8 --> interpolation animation stuff, skip for now

			if( lightType == 2 ) then l.falloff = readfloat stream * 57.2958

			lightLayer.AddNode l

			SkipBytes stream 20

			BONE_LIST[boneIndex].TheBone.name = BONE_LIST[boneIndex].TheBone.name + "_BoneRef"
			--print l
		)
	) catch()

)

/* Read Volume Target */
fn Read_ATVL stream idx=
(
	/*
		Vol_Target creation, weird use, probably the sizes are set from the center,
		this will eventually be colored red, frozen and displayed as a box,
		exactly as the SC2ArtTools menu does when clicking the Display -> collapse helpers
	*/

	if( idx==0) then ( return undefined	)

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	multiplierLength = 100
	for v=1 to tag.NbrItems do
	(
		local volTarget = HEROES_VOLTARGET()

		volTarget.bone0 = ReadLong stream + 1
		volTarget.bone1 = ReadLong stream
		volTarget.type =  ReadLong stream --> 0 Cube, 1 Sphere, 2 Capsule
		volTarget.bone2 = ReadLong stream
		-- 16bytes

		volTarget.matrix = Read4x4Matrix stream --> 64 bytes --> transformation matrix

		SkipBytes stream 24

		if(volTarget.type == 0 )/* Cube */ then multiplierLength = 200

		volTarget.size0 = ReadFloat stream * multiplierLength --> Radius or X size
		volTarget.size1 = ReadFloat stream * multiplierLength --> Height or Y size
		volTarget.size2 = ReadFloat stream * multiplierLength --> unused or Z size
		-- 12 bytes



		append ATVL_LIST volTarget
	)
	--print ATVL_LIST
)

/* Read Hit Test */
fn Read_SSGS stream idx=
(
	/*
		HitTestFuzzy is defined here, name comes from the bone list reference,
		this will eventually be colored blue, frozen and set to display as a box,
		exactly like the SC2ArtTools menu does -> display -> collapse helpers
	*/

	if( idx == 0 ) then ( return undefined )

	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	multiplierLength = 100

	for v=1 to tag.NbrItems do
	(
		local hitTest = HEROES_HITTEST()

		hitTest.type   = ReadLong stream --> 0 Cube, 1 Sphere, 2 Capsule, 3 Cylinder
		hitTest.boneId = ReadShort stream #signed +1

		SkipBytes stream 2
		-- 8bytes

		hitTest.matrix = Read4x4Matrix stream --> 64 bytes --> transformation matrix

		SkipBytes stream 24

		hitTest.size0 = ReadFloat stream * multiplierLength --> Radius or X size
		hitTest.size1 = ReadFloat stream * multiplierLength --> Height or Y size
		hitTest.size2 = ReadFloat stream * multiplierLength --> unused or Z size
		-- 12 bytes

		append SSGS_LIST hitTest
	)
	--print SSGS_LIST
)

/* Read the attachments */
fn Read_ATT stream idx=
(
	/* 20 bytes */
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.Offset #seek_set

	for i=1 to tag.NbrItems do
	(
		local att = HEROES_ATT()
		SkipBytes stream 4
		att.Name = TAGS[ReadReference stream].TagData
		att.ParentId = ReadLong stream +1 --> link it to the appropriate bone


		append ATT_LIST att
	)
	--print ATT_LIST


)
fn Read_MAT_NONSC2 stream idx=
(
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.OffSet #seek_set

	local size = 280
	/*
		15 size=268
		16 size=280
		17 size=280
		18 size=280
		19 size= 340 --> new since beta
	*/

	if( tag.Flag == 15) then size = 268
	if( tag.Flag == 19) then size = 340

	nbrMaterials = tag.NbrItems

	for m=1 to nbrMaterials do
	(
		local mat = HEROES_NONSC2_MAT() -- HEROES_Mat()

		local len = readlong stream
		local idx = readlong stream +1
		local flg = readlong stream

		mat.Name = tags[idx].TagData

        local flagA = readlong stream
        local flagB = readlong stream
        local blendMode = readlong stream
        local prio = readlong stream
        local useRTTChannels = readlong stream
        local specularity = readlong stream
        local depthBlendFallOff = readlong stream
        local cutOutTreshold = readlong stream
        local specMultiplier = readfloat stream
        local emisMultiplier = readfloat stream

        /* Assign the texture to the material */
        local Diff_Map     = undefined
        local Norm_Map     = undefined
        local Height_Map   = undefined
        local Decal_Map    = undefined
        local Spec_Map     = undefined
        local Emis_Map     = undefined
        local Emis2_Map    = undefined
        local Env_Map      = undefined
        local Envio_Map    = undefined
        local Alpha_Map    = undefined
        local Alpha2_Map   = undefined
        local Light_Map    = undefined

        for l=1 to 13 do
		(
			len = readlong stream
			ind = readlong stream +1
			flg = readlong stream

            if(tags[ind].TagData.TextureRefId > 0) then
			(
				textureIdx = tags[ind].TagData.TextureRefId + 1

                if (l==1)  then Diff_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==11) then Norm_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==12) then Height_Map  = ValidateTexture tags[textureIdx].TagData
                if (l==2)  then Decal_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==3)  then Spec_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==4)  then Glos_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==5)  then Emis_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==6)  then Emis2_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==7)  then Env_Map     = ValidateTexture tags[textureIdx].TagData
                if (l==8)  then Envio_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==9)  then Alpha_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==10) then Alpha2_Map  = ValidateTexture tags[textureIdx].TagData
                if (l==13) then Light_Map   = ValidateTexture tags[textureIdx].TagData

            )
		)


        if( Diff_Map    != undefined ) then  mat.Diff_Map =   Diff_Map
        if( Norm_Map    != undefined ) then  mat.Norm_Map       	=   Norm_Map
        if( Height_Map  != undefined ) then  mat.Height_Map 	    =   Height_Map
        if( Decal_Map   != undefined ) then  mat.Decal_Map 		    =   Decal_Map
        if( Spec_Map    != undefined ) then  mat.Spec_Map 		    =   Spec_Map
        if( Emis_Map    != undefined ) then  mat.Emis_Map 	    =   Emis_Map
        if( Emis2_Map   != undefined ) then  mat.Emis2_Map 	    =   Emis2_Map
        if( Env_Map     != undefined ) then  mat.Env_Map 		=   Env_Map
        if( Envio_Map   != undefined ) then  mat.Envio_Map 	=   Envio_Map
        if( Alpha_Map   != undefined ) then  mat.Alpha_Map	    =   Alpha_Map
        if( Alpha2_Map  != undefined ) then  mat.Alpha2_Map 	=   Alpha2_Map
        if( Light_Map   != undefined ) then  mat.Light_Map		=   Light_Map

		SkipBytes stream ( size - 208 )

		append MAT_LIST mat

	)

	-- print MAT_LIST




)

/* Read the Materials */
fn Read_MAT stream idx=
(
	/*
		Read the material properties
		TODO:
           USE if ( bUseSC2ArtTools == true ) then
	*/

    if( bUseSC2ArtTools == false) then 
    (
        Read_MAT_NONSC2 stream idx
        return undefined

    )
        
	if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.OffSet #seek_set

	local size = 280
	/*
		15 size=268
		16 size=280
		17 size=280
		18 size=280
		19 size= 340 --> new since beta
	*/

	if( tag.Flag == 15) then size = 268
	if( tag.Flag == 19) then size = 340

	nbrMaterials = tag.NbrItems

	for m=1 to nbrMaterials do
	(
		local mat = SC2_Standard_Material() -- HEROES_Mat()

		local len = readlong stream
		local idx = readlong stream +1
		local flg = readlong stream

		mat.Name = tags[idx].TagData

        local flagA = readlong stream


        local flagB = readlong stream

        /* Passes */
        if( bit.get flagB 32 == false )  then mat.MainPass = off --> Draw Geometry
        if( bit.get flagB 15 == false )  then mat.CastTransparentShadows = on
        if( bit.get flagB 6 )   then mat.castShadows = off
        if( bit.get flagB 9 )   then mat.TranslucencyDepthWrite = on --> Z Fill Pass

        /* Material Basic Parameters*/
        if( bit.get flagB 1 )  then (
            mat.VtxColor = on
            mat.ExpVtxRGBA = on
        )
        if( bit.get flagB 2 ) then (
            mat.VtxAlpha = on
            mat.ExpVtxRGBA = on
        )
        if( bit.get flagB 4 )  then mat.twoSided = on
        if( bit.get flagB 5 )  then mat.Unlit = on
        if( bit.get flagB 14 ) then mat.DepthFog = on
        if( bit.get flagB 19 ) then mat.DisableSoftBlend = on
        if( bit.get flagB 20 ) then mat.ForceDoubleLambertShading = on
        if( bit.get flagB 22 ) then mat.AcceptSplats = on
        if( bit.get flagB 26 ) then mat.OnlyAcceptSplats = on

        /* Misc */
        if( bit.get flagB 16 ) then mat.DecalLighting = on
        if( bit.get flagB 17 ) then mat.TransaprencyAffectsDOF = on
        if( bit.get flagB 18 ) then mat.TransparencyLocalLights = on
        if( bit.get flagB 21 ) then mat.HairSorting = on
        if( bit.get flagB 30 ) then mat.NoHighlights = on
        if( bit.get flagB 27 ) then mat.BackgroundObject = on
        if( bit.get flagB 31 ) then mat.ClampOutput = on

        /* Compatibility */
        if( bit.get flagB 23 ) then mat.RequiresDecal = on
        if( bit.get flagB 24 ) then mat.RequiresEmissive = on
        if( bit.get flagB 25 ) then mat.RequiresSpecular = on
        if( bit.get flagB 29 ) then mat.RequiresZFill = on


        local blendMode = readlong stream
        local prio = readlong stream
        local useRTTChannels = readlong stream
        local specularity = readlong stream
        local depthBlendFallOff = readlong stream
        local cutOutTreshold = readlong stream
        local specMultiplier = readfloat stream
        local emisMultiplier = readfloat stream

        mat.Priority = prio
        mat.depthBlendFallOff = depthBlendFallOff
        mat.HDRSpecularMul = specMultiplier
        mat.HDREmissiveMul = emisMultiplier



		--SkipBytes stream 20
		/*
			1. Diffuse
			2. Decal
			3. Specular
			4. Gloss
			5. Emissive
			6. Emissive 2
			7. Environment
			8. EnvioMap
			9. Alpha Mask
			10. Alpha Mask 2
			11. Normal Map
			12. Height Map
			13. Light Map
		*/


        /* Assign the texture to the material */
        local Diff_Map     = undefined
        local Norm_Map     = undefined
        local Height_Map   = undefined
        local Decal_Map    = undefined
        local Spec_Map     = undefined
        local Emis_Map     = undefined
        local Emis2_Map    = undefined
        local Env_Map      = undefined
        local Envio_Map    = undefined
        local Alpha_Map    = undefined
        local Alpha2_Map   = undefined
        local Light_Map    = undefined

        for l=1 to 13 do
		(
			len = readlong stream
			ind = readlong stream +1
			flg = readlong stream

            if(tags[ind].TagData.TextureRefId > 0) then
			(
				textureIdx = tags[ind].TagData.TextureRefId + 1

                if (l==1)  then Diff_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==11) then Norm_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==12) then Height_Map  = ValidateTexture tags[textureIdx].TagData
                if (l==2)  then Decal_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==3)  then Spec_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==4)  then Glos_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==5)  then Emis_Map    = ValidateTexture tags[textureIdx].TagData
                if (l==6)  then Emis2_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==7)  then Env_Map     = ValidateTexture tags[textureIdx].TagData
                if (l==8)  then Envio_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==9)  then Alpha_Map   = ValidateTexture tags[textureIdx].TagData
                if (l==10) then Alpha2_Map  = ValidateTexture tags[textureIdx].TagData
                if (l==13) then Light_Map   = ValidateTexture tags[textureIdx].TagData

            )
		)


        if( Diff_Map    != undefined ) then  mat.Diffuse.fileName         	=   Diff_Map
        if( Norm_Map    != undefined ) then  mat.NormalMap.fileName       	=   Norm_Map
        if( Height_Map  != undefined ) then  mat.HeightMap.fileName 	    =   Height_Map
        if( Decal_Map   != undefined ) then  mat.Decal.fileName 		    =   Decal_Map
        if( Spec_Map    != undefined ) then  mat.Gloss.fileName 		    =   Spec_Map
        if( Emis_Map    != undefined ) then  mat.Emissive1.fileName 	    =   Emis_Map
        if( Emis2_Map   != undefined ) then  mat.Emissive2.fileName 	    =   Emis2_Map
        if( Env_Map     != undefined ) then  mat.Environment.fileName 		=   Env_Map
        if( Envio_Map   != undefined ) then  mat.EnvironmentMask.fileName 	=   Envio_Map
        if( Alpha_Map   != undefined ) then  mat.AlphaMask.fileName 	    =   Alpha_Map
        if( Alpha2_Map  != undefined ) then  mat.AlphaMask2.fileName 	    =   Alpha2_Map
        if( Light_Map   != undefined ) then  mat.Lightmap.fileName			=   Light_Map



        if( Envio_Map != undefined ) then
        (
            mat.MatSubType = 2 --> Environment
            mat.Environment.UVMapping = 6
        )

        if( Alpha_Map != undefined ) then
        (
            mat.MatSubType = 3 --> Mask
            mat.AlphaTestThreshold = 16

            mat.BlendOp = 1
            if( Emis_Map != undefined ) then
            (
                mat.EmissiveBlendOp1 = 3
            )
        )

		SkipBytes stream ( size - 208 )

		append MAT_LIST mat

        if( m <25 ) then meditMaterials[m] = mat
		if( mat.Diffuse != undefined) then showTextureMap mat mat.Diffuse true


	)

	-- print MAT_LIST




)


fn Read_CAM stream idx=
(
    if( idx==0) then
	(
		return undefined
	)
	local tag = TAGS[idx]
	fseek stream tag.OffSet #seek_set
    local camLayer = CreateLayer "Camera"

    /* 180 bytes for 1 camera */
    for c=1 to tag.nbrItems do
    (

        local boneIndex = ReadLong stream + 1
        local cam = SC2Camera()

        cam.name = BONE_LIST[boneIndex].Name
        BONE_LIST[boneIndex].Name = BONE_LIST[boneIndex].Name + "_boneRef"
        cam.rotation = BONE_LIST[boneIndex].Rotation
        cam.position = BONE_LIST[boneIndex].Position

        i = ReadReference stream

        ReadBytes_Helper stream 8
        cam.fov = ( readfloat stream ) * 100
        ReadBytes_Helper stream 8
        useVertFOV = readlong stream
        if( useVertFOV == 1 ) then cam.useVertFOV = on else cam.useVertFOV = off
        ReadBytes_Helper stream 8
        cam.farclip = ( readfloat stream ) * 100
        ReadBytes_Helper stream 16
        cam.nearClip = ( readfloat stream ) * 100
        ReadBytes_Helper stream 16
        cam.shadowClipDistance = ( readfloat stream ) * 100
        ReadBytes_Helper stream 16
        cam.focusDistance = ( readfloat stream ) * 100
        ReadBytes_Helper stream 16
        cam.fullFocusRange = ( readfloat stream ) * 100
        ReadBytes_Helper stream 16
        cam.noFocusRange = ( readfloat stream ) * 100
        ReadBytes_Helper stream 16
        cam.dofAmount = ( readfloat stream )
        ReadBytes_Helper stream 8

        camLayer.AddNode cam

        ref = HEROES_CAMERA()
        ref.CamRef = cam
        ref.BoneRefId = boneIndex

        append CAM_LIST ref

    )
    print CAM_LIST
)

/**************************************************************************************************************************/
/*  BUILD THE STUFF */
/**************************************************************************************************************************/
fn Build_Camera =
(
    for i=1 to CAM_LIST.Count do
    (
        print BONE_LIST[CAM_LIST[i].BoneRefId].theBone

        CAM_LIST[i].CamRef.Rotation = BONE_LIST[CAM_LIST[i].BoneRefId].theBone.Rotation
        CAM_LIST[i].CamRef.Position = BONE_LIST[CAM_LIST[i].BoneRefId].theBone.Position
    )
)

/* BUILD BONES */
fn Build_Bones =
(
	/*
		Build the bone structure and the bind pose, supports the creation of bones from m3a files
	*/

	PRINT "BUILDING BONES..."

	if(BONE_LIST == undefined) then return undefined
	nBones = BONE_LIST.count
	/* Put the bones in a layer */
	boneLayer = CreateLayer "Bones"
	animBoneLayer = CreateLayer "Animated Bones"

	/* Create the bones */
	for b=1 to nBones do
	(
		/* Check if the bone already exist */
		local boneExists = false
		for obj in objects do
		(
			if(classof obj == BoneGeometry and obj.Name == BONE_LIST[b].Name ) then
			(
				BONE_LIST[b].TheBone = obj
				boneExists = true
				--print ("Bone found : " + obj.Name )
			)

		)
		if(boneExists == false ) then
		(
			local aBone = BoneSys.CreateBone [0,0,0] [0,0,0] [0,0,1]
			aBone.Name = BONE_LIST[b].Name
			print ("Bone NOT found : " + aBone.Name)
			aBone.ShowLinks = true

			aBone.Width = 0.05
			aBone.Height = 0.05

			BONE_LIST[b].TheBone = aBone

			boneLayer.AddNode aBone
		)

	)
	if(BONE_LOOKUP != undefined) then
	(
		for b=1 to BONE_LOOKUP.count do
		(
			if( BONE_LOOKUP[b] <= BONE_LIST.Count) then
			(
				local aBone = BONE_LIST[BONE_LOOKUP[b]].TheBone
			if( aBone != undefined) then animBoneLayer.AddNode aBone
			)
		)
	)

	/* Build the bone Hierarchy */
	if( gFILETYPE == ".m3") then
	(
		for b=1 to nBones do
		(


			if(BONE_LIST[b].ParentBoneId != 0) then
			(
				parentBone = BONE_LIST[ BONE_LIST[b].ParentBoneId ].TheBone
				if(parentBone != undefined and BONE_LIST[b].TheBone != undefined ) then
				(
					BONE_LIST[b].TheBone.Parent = parentBone
				)
			)
		)
	)

	with animate on
	(
		at time 0
		(
			for b = 1 to nbones do
			(

				aBone = BONE_LIST[b].TheBone
				if( aBone != undefined) then
				(
					iref = IREF_LIST[b].Matrix
					aBone.Transform = iref
				)
			)
		)
	)

	with animate on
	(
		at time 10
		(
			in coordsys parent
			(
				for b=1 to nbones do
				(

					aBone = BONE_LIST[b].TheBone
					if(aBone != undefined ) then
					(
						aBone.Rotation = BONE_LIST[b].Rotation
						aBone.Position = BONE_LIST[b].Position
						aBone.Scale = BONE_LIST[b].Scale

						aBone.SetSkinPose()
					)
				)
			)
		)
	)

)

/* BUILD THE MESHES */
fn Build_Meshes =
(
	PRINT "BUILDING MESHES..."

	/*
		Create the meshes/submeshes
		Assign a random color to the mesh if there is no materials imported
		Applies the correct uv coordinates
		Apply normals

	*/

	nMeshes = SUBMESH_LIST.count
	nFirstFace = 0

	/* Create the meshes */
	for m=1 to nMeshes do
	(
		submesh = SUBMESH_LIST[m]
		--print submesh

		local v = #()
		local n = #()
		local uv = #()

		for x=1 to submesh.nVerts do
		(
			append v VERTEX_LIST[submesh.firstVertex + x]
			append n NORMALS_LIST[submesh.firstVertex + x]
			append uv UVW_LIST[submesh.firstVertex + x]
		)

		local f = #()

		for x=1 to submesh.nIndices by 3 do
		(
			local face = [0,0,0]

			for j=1 to 3 do
			(
				local k = submesh.firstIndex + x + j - 1
				face[j] = INDICES_LIST[k]
			)
			append f face
		)

		nFirstFace = lastx

		local theMesh = mesh vertices:v vnorms:n name:submesh.Name tverts:uv faces:f

		unitLayer = CreateLayer "Unit"
		theMesh.WireColor = Color (random 0 128) (random 0 255) (random 0 128)

		buildTVFaces theMesh false
		for i = 1 to f.count do
		( setTVFace theMesh i f[i] )

		update theMesh
		unitLayer.AddNode theMesh
		SUBMESH_LIST[m].TheMesh = theMesh
	)



)

/* BUILD VOL TARGET */
fn Build_VolTarget=
(
	/*
		Weird stuff when setting the center to the refering bone, this does not always work...
	*/

	--> 0 Cube, 1 Sphere, 2 Capsule

	for i=1 to ATVL_LIST.Count do
	(
		local volTarget = ATVL_LIST[i]
		local refBone = BONE_LIST[volTarget.Bone0].theBone
		local obj = undefined



		if( volTarget.type == 0) then /* CUBE */
		(
			obj = box name:refBone.Name height:volTarget.size2 width:volTarget.size0 length:volTarget.size1

			obj.rotation = refBone.Rotation
			obj.pos = refBone.position

		)
		if( volTarget.type == 1) then /* SPHERE */
		(
			obj = sphere name:refBone.Name radius:volTarget.size0

			obj.rotation = refBone.Rotation
			obj.pos = refBone.position

		)

		if( volTarget.type == 2) then /* CAPSULE */
		(
			local heigth = volTarget.size0 + volTarget.size1
			obj = capsule name:refBone.Name sides:12 radius:volTarget.size0 height:heigth heighttype:0
			obj.pivot = obj.center
			obj.rotation = refBone.Rotation
			obj.pos = refBone.position
		)

		if( volTarget.type == 3) then /* CYLINDER */
		(

			obj = Cylinder name:refBone.Name sides:12 radius:volTarget.size0 height:volTarget.size1

			obj.rotation = refBone.Rotation
			obj.pos = refBone.position
		)



		if(obj !=undefined ) then
		(
			local layer = CreateLayer "Vol_Target"
			layer.AddNode obj
			layer.AddNode refBone
			obj.parent = refBone
			obj.wirecolor = color 255 0 0
			obj.boxmode = on
			obj.renderable = off
			freeze obj
			Hide refBone
		)
		BONE_LIST[volTarget.Bone0].theBone.name = BONE_LIST[volTarget.Bone0].theBone.name + "_BoneRef"
	)


)

/* BUILD HIT TEST */
fn Build_HitTestFuzzy=
(
	--> 0 Cube, 1 Sphere, 2 Capsule

	for i=1 to SSGS_LIST.Count do
	(
		local hitTest = SSGS_LIST[i]
		local refBone = BONE_LIST[hitTest.BoneId].theBone

		local obj = undefined

		if( hitTest.type == 0) then /* CUBE */
		(
			obj = box name:refBone.Name height:hitTest.size2 width:hitTest.size0 length:hitTest.size1

			obj.rotation = refBone.Rotation
			obj.pos = refBone.position

		)
		if( hitTest.type == 1) then /* SPHERE */
		(
			obj = sphere name:refBone.Name radius:hitTest.size0

			obj.rotation = refBone.Rotation

			obj.pos = refBone.position  -- + [0,0,hitTest.size0]

		)

		if( hitTest.type == 2) then /* CAPSULE */
		(
			local height = hitTest.size0 * 2 + hitTest.size1
			obj = capsule name:refBone.Name sides:12 radius:hitTest.size0  height:height heighttype:0
			--obj.pivot = obj.center
			obj.rotation = refBone.Rotation
			obj.pos = refBone.position
		)

		if( hitTest.type == 3) then /* CYLINDER */
		(

			obj = Cylinder name:refBone.Name sides:12 radius:hitTest.size0 height:hitTest.size1

			obj.rotation = refBone.Rotation
			obj.pos = refBone.position
		)



		if(obj !=undefined ) then
		(
			local layer = CreateLayer "HitTestFuzzy"
			layer.AddNode obj
			layer.AddNode refBone
			obj.parent = refBone
			obj.wirecolor = color 0 0 255
			obj.boxmode = on
			obj.renderable = off
			freeze obj
			hide refBone
		)
		BONE_LIST[hitTest.BoneId].theBone.name = BONE_LIST[hitTest.BoneId].theBone.name + "_BoneRef"

	)


)

/* BUILD ATT POINTS */
fn Build_Attachments=
(
	/*
		since the export of the model refers to double naming of object
		-> because the bone name is most of the time the actual attachment,
		I renamed these bones with the suffix _boneRef
	*/
	if ( bUseSC2ArtTools == true ) then
	(
		for i=1 to ATT_LIST.Count do
		(
			local attLayer = CreateLayer "Attachment Points"

			local att = ATT_LIST[i]

			local refBone = BONE_LIST[att.ParentId].theBone

			local obj = undefined

			obj = SC2AttachPt name:att.Name scale:[0.5,0.5,0.5]
			obj.Rotation = refBone.Rotation
			obj.pos = refBone.Pos
			obj.Parent = refBone

			attLayer.AddNode obj
			attLayer.AddNode refBone
			hide refBone
			freeze obj
			BONE_LIST[att.ParentId].theBone.name = BONE_LIST[att.ParentId].theBone.name + "_BoneRef"
		)
	)

	if ( bUseSC2ArtTools == false ) then
	(
		for i=1 to ATT_LIST.Count do
		(
			local attLayer = CreateLayer "Attachment Points"

			local att = ATT_LIST[i]

			local refBone = BONE_LIST[att.ParentId].theBone

			local obj = undefined

			obj = CreateAttachmentPt att.Name --SC2AttachPt name:att.Name scale:[0.5,0.5,0.5]
			obj.Rotation = refBone.Rotation
			obj.pos = refBone.Pos
			obj.Parent = refBone

			attLayer.AddNode obj
			attLayer.AddNode refBone
			hide refBone
			freeze obj
			BONE_LIST[att.ParentId].theBone.name = BONE_LIST[att.ParentId].theBone.name + "_BoneRef"
		)

	)

)

/* IMPORT TEXTURES */
fn Build_Materials =
(
	PRINT "IMPORTING NON SC2 TEXTURES..."


	if ( bUseSC2ArtTools == false ) then
	(
		for i=1 to MAT_LIST.count do
		(
			try
			(
				mat = MAT_LIST[i]

				SC2Mat =  Standardmaterial () -- SC2_Standard_Material()
				SC2Mat.Name 		= mat.Name

				if( mat.Diff_Map    !=undefined) then
				(
					--SC2Mat.Diffuse.fileName         =   mat.Diff_Map
					SC2Mat.diffuseMapEnable = on
					SC2Mat.diffuseMap = Bitmaptexture fileName:mat.Diff_Map
					SC2Mat.ambient = color 0 0 0
					SC2Mat.Diffuse = color 0 0 0
					showTextureMap SC2Mat SC2Mat.diffuseMap true
					SC2Mat.adLock = off --> applies a team color
					SC2Mat.Diffuse = color 255 0 0
				)
				if( mat.Norm_Map    !=undefined) then
				(
					SC2Mat.bumpMapEnable = on
					SC2Mat.bumpMap = Normal_Bump ()
					SC2Mat.bumpMap.normal_map = Bitmaptexture fileName:mat.Norm_Map
					SC2Mat.bumpMap.flipred = on
					SC2Mat.bumpMapAmount = 20

				)

				if( mat.Spec_Map    !=undefined) then
				(
					SC2Mat.specularMapEnable = on
					SC2Mat.specularMap = Bitmaptexture fileName:mat.Spec_Map
					SC2Mat.specularLevel = 50
					SC2Mat.glossiness = 30

				)
				if( mat.Emis_Map    !=undefined) then
				(

					SC2Mat.selfillumMapEnable = on
					SC2Mat.useSelfIllumColor = on
					SC2Mat.selfillumMap = Bitmaptexture fileName:mat.Emis_Map
				)


				if( mat.Alpha_Map   !=undefined) then
				(
					SC2Mat.opacityMapEnable = on
					SC2Mat.opacityMap = Bitmaptexture fileName:mat.Alpha_Map
					SC2Mat.opacityMap.monooutput = 1
				)
print "What was found :"
print SC2Mat

				meditMaterials[i] = SC2Mat

				MAT_LIST[i].MaterialRef = SC2Mat
			)
			catch
			(
				PRINT "[ERROR]"
				PRINT (getCurrentException())

			)
		)

	)


)

/* APPLY MATERIALS TO MESHES */
fn ApplyMaterials =
(
	PRINT "APPLYING MATERIALS"

    Build_Materials()
    
	for i= 1 to MESHMAT_LIST.Count do
	(
		local msh
		local mat

		if(SUBMESH_LIST[MESHMAT_LIST[i].MeshId] != undefined ) then msh = SUBMESH_LIST[MESHMAT_LIST[i].MeshId].TheMesh
		if(MAT_LIST[MESHMAT_LIST[i].matID] != undefined ) then 
        (
            mat = MAT_LIST[MESHMAT_LIST[i].matID]
            if ( bUseSC2ArtTools == false ) then mat = MAT_LIST[MESHMAT_LIST[i].matID].MaterialRef
        )

		if(msh!=undefined and mat!=undefined ) then msh.Material = mat

	)

)

/* Clean up the scene */
fn CleanUpScene=
(
	/* Since most bones are only there as a reference and not really used as an animated feature, hide these bones using the layer */
	boneLayer = CreateLayer "Bones"
	boneLayer.IsHidden = true


)

/* SKIN THE MODEL */
fn Apply_Skin=
(
	/*
		Most annoying part in the whole script, didn't have this much issues with my D3 import script :/

		Until now, still not 100% correct, sometimes this misses the vertex weighting completly.. :'(

		TODO:
			Figure out the correct way to apply these arrays of 4 weights and 4 bone indexes to the mesh
			Spent too much time on this already and probably will do more, but sometimes it is just faster to do this manually !!

	*/
	for m=1 to SUBMESH_LIST.Count do
	(

		local msh = SUBMESH_LIST[m]
		local obj = SUBMESH_LIST[m].theMesh
		local mshSkin = skin name:"Skin"

		max modify mode
		addmodifier obj mshSkin

		modPanel.setCurrentObject mshSkin


		for i=1 to msh.nBones do
		(

			local b = BONE_LIST[BONE_LOOKUP[msh.firstBoneLookup + i]].theBone

			skinOps.addBone mshSkin b 0
		)

		update obj
		max views redraw

		--disableSceneRedraw()


		for v=1 to msh.nVerts do
		(


			skinOps.ReplaceVertexWeights mshSkin v WEIGHTBONE_LIST[msh.firstVertex + v].BoneIndexes  WEIGHTBONE_LIST[msh.firstVertex + v].Weights

		)



		update obj
		--enableSceneRedraw()
		redrawViews()
	)

)

/* save animation info*/
fn SaveAnimInfo =
(
	animPropsList = STC_LIST
	
	local cnt="["
	local isFirst=true

	for i=1 to nbrValidSTCs do
	(
		local props = animPropsList[i]
		local underscorePos = findstring props.Name "_"

		if( underscorePos != undefined) then
		(
			props.Name = substring props.Name 1 (underscorePos-1)
		)
		
		if(isFirst) then
		(
			isFirst=false
		)
		else
		(
			cnt +=","
		)
				
		local val = "{"
		val += "\"name\":\"" +props.Name + "\","
		val += "\"firstFrame\":" + props.firstFrame as string + ","
		val += "\"lastFrame\":" + props.lastFrame as string + ","
		val += "\"rarity\" : " 	 + props.frequency as string + ","
		val += "\"moveSpeed\" : "  + props.MovementSpeed as string + ","
		val += "\"nonLoop\" : " 	 + props.NonLooping as string +"}\r\n"
		
		cnt+= val 
	)

	cnt +="]\r\n"

	print (format "AnimationInfo:%" cnt)

	local animInfoPath=pathConfig.convertPathToAbsolute "animinfos/dd"

	makeDir animInfoPath all:true
	
	local baseFileName=getFilenameFile sCurrentFile

	local animInfoFileName= pathConfig.appendPath animInfoPath baseFileName
	
	animInfoFileName+=".json"

	animInfoFile = createfile animInfoFileName

	format "%" cnt to:animInfoFile

	close animInfoFile
)

/* create StarCraft 2 AnimProps */
fn SetAnimProps=
(
	/*
		check if there is a note track called "starAnimTrack"-> this is where Blizzard stores its animations

		NOTE: if you already have a animation track, be aware this will be deleted !!!

	*/
	local starAnimTrack = undefined
	local nNoteTracks = numNoteTracks rootNode
	if(  nNoteTracks > 0 ) then
	(
		for n=1 to nNoteTracks do deleteNoteTrack rootNode (getNoteTrack rootNode n)
	)

	if( numNoteTracks rootNode == 0 ) then
	(
		starAnimTrack = notetrack "starAnimTrack"
		addNoteTrack rootNode starAnimTrack
	)
	animPropsList = STC_LIST

	for i=1 to nbrValidSTCs do
	(
		local props = animPropsList[i]
		local underscorePos = findstring props.Name "_"

		if( underscorePos != undefined) then
		(
			props.Name = substring props.Name 1 (underscorePos-1)
		)

		local noteExists = getNoteKeyIndex starAnimTrack props.firstFrame
		if( noteExists == undefined) then
		(
			local startNote = AddNewNoteKey starAnimTrack props.firstFrame -- props.startFrame
			local endFrame = props.LastFrame -- props.startFrame + (( props.endFrame * 30 / 1000.0) as integer)
			local endNote = AddNewNoteKey starAnimTrack endFrame

			if( props.MovementSpeed > 1000) then props.MovementSpeed = 450 --> don't know but for heroes this is an issue on the hero models

			local val = props.Name + "\r\n"
				  val += "rarity = " 	 + props.frequency as string + "\r\n"
				  val += "moveSpeed = "  + props.MovementSpeed as string + "\r\n"
				  val += "nonLoop = " 	 + props.NonLooping as string + "\r\n"
				  val += "default_Anim = false\r\nsub_anim = false\r\ndefaultPriority = 0"

			startNote.Value = val
			endNote.Value = val
	
			if(props.firstFrame!=undefined) then
			(
				FrameTagManager.CreateNewTag (props.Name+"_Start") props.firstFrame
			)
				
	
			if(props.LastFrame!=undefined) then
			(
				FrameTagManager.CreateNewTag (props.Name+"_End") props.LastFrame
			)	



			PRINT ( "Added animation " + props.Name + " (" + props.firstFrame as string + " " + props.LastFrame as string + " )" )
		)
	)

	if(bSaveAnimationInfo) then
	(
		SaveAnimInfo()
	)
)

/* APPLY THE ANIMATION*/
fn ApplyAnimation=
(
	PRINT "APPLYING ANIMATION... this can take some time..."

	/*
		frame used for binding position, all animations must start after frame 10 !

	*/

	-- find matching SEQ_refId
	nbrValidSTCs = 0
	for g=1 to STG_LIST.Count do
	(
		for x=1 to STG_LIST[g].STC_ids.Count do
		(
			local stcId = STG_LIST[g].STC_ids[x] +1
			STC_LIST[stcId].SEQ_refId = g

			if( stcId > nbrValidSTCs ) then nbrValidSTCs = stcId
		)

	)

	-- build the stc animations -->TODO must be changed to the correct SEQS animations
	local firstFrame = nAnimationSeparate

	for i=1 to nbrValidSTCs do
	(
		local seqsId = STC_LIST[i].SEQ_refId
		local nbrFrames = (SEQS_LIST[seqsId].endFrame * 30 / 1000.0 ) as integer  --> end frame is actually wrong, this is the number of seconds the animation takes

		STC_LIST[i].FirstFrame = firstFrame
		STC_LIST[i].LastFrame = firstFrame + nbrFrames
		STC_LIST[i].NonLooping = SEQS_LIST[seqsId].NonLooping
		STC_LIST[i].Frequency = SEQS_LIST[seqsId].Frequency
		STC_LIST[i].MovementSpeed = SEQS_LIST[seqsId].MovementSpeed
		firstFrame += (nbrFrames + nAnimationSeparate) as integer

		if( i> 1) then
		(
			lowerBody = FindString ( toLower STC_LIST[i-1].name ) "_lowerbody"
			if( lowerBody !=undefined) then
			(
				STC_LIST[i].FirstFrame = STC_LIST[i-1].FirstFrame
				STC_LIST[i].LastFrame = STC_LIST[i-1].LastFrame
			)
		)
	)

	/* Start animating the bones */
	for i=1 to BONE_LIST.count do
	(
		if(BONE_LIST[i].isAnimated) then --> only animated bones
		(
			local b = BONE_LIST[i].theBone
			if( b == undefined ) do continue
			local boneRotId = BONE_LIST[i].AnimRefRotation.animID
			local bonePosId = BONE_LIST[i].AnimRefPosition.animID
			local boneSclId = BONE_LIST[i].AnimRefScale.animID

			local boneRotationAnimation = undefined
			local bonePositionAnimation = undefined

			local rotFrameList = undefined
			local posFrameList = undefined

			local rotKeyList = undefined
			local posKeyList = undefined

			for c=1 to nbrValidSTCs do
			(
				local rotAnimations = #()
				local posAnimations = #()
				local rot_sd = undefined
				local pos_sd = undefined

				firstFrame = STC_LIST[c].FirstFrame
					
				for a=1 to STC_LIST[c].AnimationIds.count do
				(
					if( STC_LIST[c].AnimationIds[a] == boneRotId) then
					(
						rot_sd = STC_LIST[c].AnimationRefs[a].sd
						local sdindx = STC_LIST[c].AnimationRefs[a].sdindx --> should be 4

						boneRotationAnimation = STC_LIST[c].SD4Q_data --> refers to 4

						local anim = MAX_ANIMATION()

						anim.FrameList = boneRotationAnimation[rot_sd].FrameList.TagData
						anim.KeyList = boneRotationAnimation[rot_sd].Keys.TagData

						append rotAnimations anim
					)

					if( STC_LIST[c].AnimationIds[a] == bonePosId) then
					(
						pos_sd = STC_LIST[c].AnimationRefs[a].sd
						local sdindx = STC_LIST[c].AnimationRefs[a].sdindx --> should be 3

						bonePositionAnimation = STC_LIST[c].SD3V_data

						local anim = MAX_ANIMATION()

						anim.FrameList = bonePositionAnimation[pos_sd].FrameList.TagData
						anim.KeyList = bonePositionAnimation[pos_sd].Keys.TagData

						for k=1 to anim.KeyList.count do anim.KeyList[k] *= 100.0

						append posAnimations anim
					)

				) --> end animationIds


					-- APPLY ROTATION --> always first apply rotation since this is done using a quaternian transformation matrix
				local prevTime = undefined

				for r=1 to rotAnimations.count do
				(
					for frame=1 to rotAnimations[r].FrameList.Count do
					(

						local t = firstFrame + (rotAnimations[r].FrameList[frame] * 30  / 1000.0 ) as integer

						if( prevTime != t) then
						(
							prevTime = t --> this is to prevent multiple transformations on the same time frame
							local q = rotAnimations[r].KeyList[frame]

							--print ( t as string + ":" + q as string )

							with animate on
							(
								at time t (

									b.assumeskinpose()
									local mtrx = matrix3 1
									rotate mtrx (inverse q)
									if (b.parent != undefined) then
									(
											mtrx = mtrx * b.parent.transform --> check if this is necessary!!
									)
									b.transform = mtrx
									deleteKey b.position.controller (numKeys b.position.controller)
									deleteKey b.scale.controller (numKeys b.scale.controller)


								)
							)

						)
					)
				)

				-- APPLY POSITION
				local prevTime = undefined

				for p=1 to posAnimations.count do
				(

					for frame=1 to posAnimations[p].FrameList.count do
					(

						local t = firstFrame + (posAnimations[p].FrameList[frame] * 30  / 1000.0 ) as integer						

						if( prevTime != t) then
						(
							prevTime = t --> this is to prevent multiple transformations on the same time frame
							local pos = posAnimations[p].KeyList[frame]

							--print ( t as string + ":" + q as string )
							with animate on
								at time t
									in coordsys parent b.position = pos

						)
					)
				)




			) --> end STC_LIST


		)
	)

	--print SEQS_LIST

	SetAnimProps()



)

/**********************************************************************************************************************************/
/* START READING THE FILE */
/**********************************************************************************************************************************/

fn Read file=
(
	if( doesFileExist file == false ) then return undefined

	ClearListener()
	SetWaitCursor()

	ResetGlobals()

	local assetPos = findstring (ToUpper file) @"\ASSETS\"
	if(assetPos != undefined ) then ASSETS_FOLDER = substring file 1 assetPos
	if(assetPos == undefined ) then ASSETS_FOLDER = ""

	/* START */

	modlIndex = 0

	vertexIndex = 0
	boneLookupIndex = 0
	indicesIndex = 0
	meshIndex = 0
	lightIndex = 0
	cameraIndex = 0
	particleIndex = 0
	particleCopyIndex = 0
	volTargetIndex = 0
	attachmentIndex = 0
	fuzzyHitIndex = 0
	seqIndex = 0
	stcIndex = 0
	stgIndex = 0
	stsIndex = 0
	seqEventIndex = 0
	seqVector2Index = 0
	seqVector3Index = 0
	seqRealIndex = 0
	seqColorIndex = 0
	seqShortIndex = 0
	seqUShortIndex = 0
	seqUByteIndex = 0
	seqQuatIndex = 0
	seqUByteIndex = 0
	seqBoundIndex = 0
	boneIndex = 0
	irefIndex = 0
	eventIndex = 0
	msecIndex = 0

	billboardIndex = 0
	projectionIndex = 0
	forcesIndex = 0
	warpIndex = 0
	rigidbodyIndex = 0
	ikIndex = 0
	turrentIndex = 0
	turrentIndex = 0

	materialIndex = 0
	standardMatIndex = 0
	meshMatIndex = 0
	displaceMatIndex = 0
	compositeMatIndex = 0
	terrainMatIndex = 0
	creepMatIndex = 0
	volumeMatIndex = 0
	noiseMatIndex = 0
	splatMatIndex = 0

	stream = fOpen file "rb"

	header = ReadFourCC stream
	ofsTags = ReadLong stream
	nTags = ReadLong stream

	ClearListener()

	/* READ THE TAGS*/
	fSeek stream ofsTags #seek_set
	for i=1 to nTags do
	(
		local tag = HEROES_TAG()

		tag.Name = ReadFourCC stream
		tag.Offset = ReadLong stream
		tag.NbrItems = ReadLong stream
		tag.Flag = ReadLong stream

		if(tag.name == "MODL") then modlIndex = i    		--> Root model

		if(tag.name == "U8__") then vertexIndex = i  		--> Vertices
		if(tag.name == "DIV_") then indicesIndex = i    	--> Indices

		if(tag.name == "REGN") then meshIndex = i    		--> Submeshes

		if(tag.name == "LITE") then lightIndex = i   		--> lights
		if(tag.name == "CAM_") then cameraIndex = i  		--> cameras
		if(tag.name == "PAR_") then particleIndex = i  		--> particles
		if(tag.name == "PARC") then particleCopyIndex = i  	--> particle copy
		if(tag.name == "ATVL") then volTargetIndex = i  	--> volume target
		if(tag.name == "ATT_") then attachmentIndex = i  	--> attachment points
		if(tag.name == "SSGS") then fuzzyHitIndex = i  		--> fuzzy hit test

		if(tag.name == "SEQS") then seqIndex = i     		--> Animation sequences
		if(tag.name == "STC_") then stcIndex = i     		--> Sequence transformation collections
		if(tag.name == "STG_") then stgIndex = i     		--> Sequence transformation groups
		if(tag.name == "STS_") then stsIndex = i     		--> Sequence transformation sets

		if(tag.name == "BONE") then boneIndex = i   		--> bones
		if(tag.name == "IREF") then irefIndex = i	 		--> initial pose
		if(tag.name == "EVNT") then eventIndex = i	 		--> animation events
		if(tag.name == "MSEC") then msecIndex = i	 		--> animation ...

		if(tag.name == "BBSC") then billboardIndex = i  	--> billboards
		if(tag.name == "PROJ") then projectionIndex = i  	--> projections
		if(tag.name == "FOR_") then forcesIndex = i  		--> forces
		if(tag.name == "WRP_") then warpIndex = i  			--> warps
		if(tag.name == "PHRB") then rigidbodyIndex = i  	--> physical rigid body
		if(tag.name == "IKJT") then ikIndex = i  			--> Inverse Kinematics joint
		if(tag.name == "PATU") then turrentIndex = i  		--> turrent
		if(tag.name == "TRGD") then turrentIndex = i  		--> turrent behaviour

		if(tag.name == "MATM") then materialIndex = i     	--> materials
		if(tag.name == "MAT_") then standardMatIndex = i  	--> standard materials
		if(tag.name == "BAT_") then meshMatIndex = i  		--> mesh matching material
		if(tag.name == "DIS_") then displaceMatIndex = i  	--> displacement materials
		if(tag.name == "CMP_") then compositeMatIndex = i  	--> composite materials
		if(tag.name == "TER_") then terrainMatIndex = i  	--> terrain materials
		if(tag.name == "CREP") then creepMatIndex = i    	--> creap materials
		if(tag.name == "VOL_") then volumeMatIndex = i   	--> volume materials
		if(tag.name == "VON_") then noiseMatIndex = i    	--> noise materials
		if(tag.name == "STBM") then splatMatIndex = i    	--> splat materials


		if(tag.name == "CHAR") then tag.TagData = ReadCharTag stream tag
		if(tag.name == "LAYR") then tag.TagData = ReadLAYRTag stream tag
		if(tag.name == "U32_") then tag.TagData = ReadU32_Tag stream tag
		if(tag.name == "U16_") then tag.TagData = ReadU16_Tag stream tag
		if(tag.name == "I32_") then tag.TagData = ReadI32_Tag stream tag
		if(tag.name == "I16_") then tag.TagData = ReadI16_Tag stream tag
		if(tag.name == "VEC2") then tag.TagData = ReadVEC2_Tag stream tag
		if(tag.name == "VEC3") then tag.TagData = ReadVEC3_Tag stream tag
		if(tag.name == "REAL") then tag.TagData = ReadREAL_Tag stream tag
		if(tag.name == "BNDS") then tag.TagData = ReadBNDS_Tag stream tag
		if(tag.name == "QUAT") then tag.TagData = ReadQUAT_Tag stream tag

		append TAGS tag
	)

	/* READ THE ANIMATION DATA*/
	for i=1 to nTags do
	(
		local tag = TAGS[i]

		if(tag.name == "SDEV") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SD2V") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SD3V") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDR3") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDCC") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDS6") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDU6") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDU3") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SD4Q") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDFG") then tag.TagData = ReadSD_Tag stream tag
		if(tag.name == "SDMB") then tag.TagData = ReadSD_Tag stream tag
	)

	/* READ THE DATA */
	Read_MODL stream modlIndex
	Read_SEQS stream seqIndex
	Read_STG  stream stgIndex
	Read_STS  stream stsIndex
	Read_STC  stream stcIndex
	Read_BONE stream boneIndex
	Read_IREF stream irefIndex
	Read_DIV  stream indicesIndex
	Read_VERT stream vertexIndex
	Read_REGN stream meshIndex
	Read_BAT  stream meshMatIndex
	Read_MATM stream materialIndex  --> TODO should be directly creating the SC2Materials, is too much data for a struct!!
	Read_LITE stream lightIndex 	--> this will also build the lights
	Read_ATVL stream volTargetIndex
	Read_ATT  stream attachmentIndex
	Read_MAT  stream standardMatIndex
	Read_SSGS stream fuzzyHitIndex
    Read_CAM  stream cameraIndex
	/*
		TODO
	*/
	-- Read_PAR
	-- Read_FOR
	-- Read_PHRB
	-- Read_PROJ
	-- Read_WARP

	--> Find out where the HitTestTight capsule is stored

	fclose stream
	GC()

)


fn Main file=
(
	sCurrentFile=file

	/* READ THE MODEL */
	Read file

	/* -- BUILD THE MODEL */
	gFILETYPE = toLower (getfilenametype file)
	if( gFILETYPE == ".m3") then
	(

		Build_Meshes()

		if(bBuildBones) then
		(
			Build_Bones()

			if( bBuildVolTarget ) then Build_VolTarget()
			if( bBuildHitTest ) then Build_HitTestFuzzy()
			if( bBuildAtt ) then Build_Attachments()
			if( bBuildSkin ) then Apply_Skin()
			if( bBuildAnim ) then ApplyAnimation()
            Build_Camera()
        )

		if( bBuildMat ) then
		(
			Build_Materials()
			ApplyMaterials()
		)
		CleanUpScene()

	)

	if( gFILETYPE == ".m3a") then
	(
		Build_Bones()
		ApplyAnimation()

	)


)

/**********************************************************************************************************************************
	CREATE THE UTILITY
**********************************************************************************************************************************/
UTILITY HeroesOfTheStormImport "TM's M3 Import (v2.1)"
(
	Group "Model Import"
	(
		Label lbl1 "Supports" align:#left
		Label lbl2 "- StarCraft 2" align:#left
		Label lbl3 "- Heroes of the Storm" align:#left
		Label lbl20
		Label lbl30 "?015 by Taylor Mouse"
		Label lbl10 "v2.1"

		CheckBox cbUseSC2ArtTools "Use SC2 Art Tools"

		EditText txtSelectedFile align:#left
		Button bSelectFile "select file ..." align:#right

		Label lbl100 "Import:" align:#left
		CheckBox cbBuildMat "Materials"
		CheckBox cbBuildBones "Bones" tooltip:"Unchecking this will uncheck all depending checkboxes aswell"
		CheckBox cbBuildVolTarget "Volume Targets"
		CheckBox cbBuildHitTest "Hit Tests"
		CheckBox cbBuildAtt "Attachments"
		CheckBox cbBuildAnim "Animations"
		CheckBox cbBuildSkin "Skin"
		CheckBox cbSaveAnimInfo "Save Animation Info"

		Button bGo "Import..." height:35 width:100

	)
	on HeroesOfTheStormImport OPEN DO
	(
		cbBuildBones.Checked = true
		cbBuildVolTarget.Checked = true
		cbBuildHitTest.Checked = true
		cbBuildAtt.Checked = true
		cbBuildAnim.Checked = true
		cbBuildMat.Checked = true
		cbBuildSkin.Checked = true
		cbUseSC2ArtTools.Checked = true
		cbSaveAnimInfo.Checked = true
	)

	on cbBuildBones CHANGED theState do
	(
		if(bBuildBones) then
		(
			bBuildBones = false
			bBuildHitTest = false
			bBuildAtt = false
			bBuildAnim = false
			bBuildVolTarget = false
			bBuildSkin = false

			cbBuildVolTarget.Checked = false
			cbBuildHitTest.Checked = false
			cbBuildAtt.Checked = false
			cbBuildAnim.Checked = false
			cbBuildSkin.Checked = false
		)
		else
		(
			bBuildBones = true
		)

	)

	on cbUseSC2ArtTools CHANGED theState do
	(
		if ( bUseSC2ArtTools == true ) then
		(	bUseSC2ArtTools = false )
		else
		(	bUseSC2ArtTools = true )


	)



	on cbBuildSkin CHANGED theState do
	(
		if( bBuildBones == true ) then
		(
			if(bBuildSkin) then bBuildSkin = false else bBuildSkin = true
		)
		else
		( cbBuildSkin.Checked = false )
	)


	on cbBuildHitTest CHANGED theState do
	(
		if( bBuildBones == true ) then
		(
			if(bBuildHitTest) then bBuildHitTest = false else bBuildHitTest = true
		)
		else
		( cbBuildHitTest.Checked = false )
	)


	on cbBuildAtt CHANGED theState do
	(
		if( bBuildBones == true ) then
		(
			if(bBuildAtt) then bBuildAtt = false else bBuildAtt = true
		)
		else
		( cbBuildAtt.Checked = false )
	)

	on cbBuildAnim CHANGED theState do
	(
		if( bBuildBones == true ) then
		(
			if(bBuildAnim) then bBuildAnim = false else bBuildAnim = true
		)
		else
		( cbBuildAnim.Checked = false )
	)

	on cbBuildVolTarget CHANGED theState do
	(
		if( bBuildBones == true ) then
		(
			if(bBuildVolTarget) then bBuildVolTarget = false else bBuildVolTarget = true
		)
		else
		( cbBuildVolTarget.Checked = false )
	)

	on cbSaveAnimInfo CHANGED theState do
	(

		if(bSaveAnimationInfo) then 
		(	
			bSaveAnimationInfo = false
		)
		else 
		(
			bSaveAnimationInfo = true
		)

	)


	ON bSelectFile PRESSED DO
	(

		file = getOpenFileName \
			caption:"Heroes of the Storm" \
			types:"Starcraft 2 & Heroes of the Storm(*.m3)|*.m3|Animation Files(*.m3a)|*.m3a|All Files|*.*" \
			historyCategory:"HeroesPresetFolder"

        try
        ( 
            x = SC2_Standard_Material()
        )
        catch
        (
            bUseSC2ArtTools = false
            cbUseSC2ArtTools.Checked = false
        )
        
        
		if(file!=undefined ) then txtSelectedFile.Text = file
	)

	On bGo PRESSED do
	(
		setWaitCursor()
		if(txtSelectedFile.Text != undefined and (DoesFileExist txtSelectedFile.Text )) then
		(
			Main txtSelectedFile.Text

			enableSceneRedraw()
			redrawViews()

			PRINT "DONE"
		)
		enableSceneRedraw()
		RedrawViews()
		setArrowCursor()
	)

)


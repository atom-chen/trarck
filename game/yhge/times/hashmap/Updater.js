(function  () {    var Scheduler=yhge.times.Scheduler;    //根据不同平台实现更新器功能。    var Updater=yhge.times.Updater=function  () {        this.initialize.apply(this,arguments);    };    Updater.prototype={        initialize:function  (scheduler) {            this._tasks=[];            this._updateTasks={};            this.taskIdIndex=1;            this.updateTaskIdIndex=1;            //regeist to scheduler            scheduler && scheduler.addTask(this._runUpdate,yhge.times.Scheduler.Updater,this);            scheduler && scheduler.addTask(this._run,yhge.times.Scheduler.Updater,this);            //Updater._instance=this;        },        //TODO 分成二部分run，一种是可以设置时间间隔的，一种是使用帧率的。        _run:function  (delta) {            //for(var i=0,l=this._tasks.length,task;i<l;i++){            //由于在一轮中，可能有新的任务加进来，为了即时处理，数组长度可能动态改变            //主要是防范删除task除错，对于新加进行来的任务放在下一轮中处理完全可以。            //使用延迟执行的办法来防止删除。            var delays=[];            for(var i=0,task;i<this._tasks.length;i++){                task=this._tasks[i];                task.leftTime-=delta;                if(task.leftTime<=0){                    delays.push(task);                    task.leftTime+=task.interval;                }            }            for(var i=0,l=delays.length,task;i<l;i++){                task=delays[i];                task.action.call(task.target,delta);            }        },        _runUpdate:function () {            var task;            for(var i in this._updateTasks){                task=this._updateTasks[i];                task.action.call(task.target,delta);            }        },        //delay为0则表示和更新器时间同步。如果delay小于每帧的间隔时间，则和最小帧时间同步，也就是同步update。        add:function  (target,fun,interval) {            //TODO support args            //var args=Array.slice.call(arguments,3),//the first for delta            var args=Array.prototype.slice.call(arguments,4),                id=this.taskIdIndex++;            this._tasks.push({target:target,action:fun,interval:interval,leftTime:interval,args:args,id:id});            return id;        },        remove:function  (id) {            for(var i=0;i<this._tasks.length;i++){//length 需要每次计算                if(this._tasks[i].id==id){                    this._tasks.splice(i,1);                    break;                }            }        },        schedule:function(target,fun,interval){            //TODO support args            //var args=Array.prototype.slice.call(arguments,3),//the first for delta            var args=Array.prototype.slice.call(arguments,4),                id=this.taskIdIndex++;            this._tasks.push({target:target,action:fun,interval:interval,leftTime:interval,args:args,id:id});            return id;        },        unschedule:function (target,fun) {            for(var task,i=0;i<this._tasks.length;i++){//length 需要每次计算                task=this._tasks[i];                if( task.action==fun &&( !target || task.target==target)){                    this._tasks.splice(i,1);                    break;                }            }        },        scheduleUpdate:function (target) {            var fun=target.update;            if(fun){                var id=this.updateTaskIdIndex++;                this._updateTasks[id]={target:target,action:fun,args:args,id:id};                return id;            }        },        unscheduleUpdate:function (target) {            var fun=target.update;            if(fun){                var task;                for(var i in this._updateTasks){//length 需要每次计算                    task=this._updateTasks[i];                    if( task.action==fun &&( !target || task.target==target)){                        delete this._updateTasks[i];                        break;                    }                }            }        }    };    Updater.getInstance=function  (scheduler) {        if (!this._instance) {            this._instance = new Updater(scheduler);        }        return this._instance;    }})();